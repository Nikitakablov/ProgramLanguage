// Вычисление факториала - это например 5! = 5 * 4 * 3 * 2 * 1. 
// int Factorial(int n)
// {
//     // 1! = 1
//     // 0! = 1
//     if (n == 1) return 1;  /*«если мы дошли до единицы (n = 1), мы должны
// вернуть 1». Почему? Это определение факториала: 1! = 1. Кстати, отметим, что 0! — это тоже 1.**/
//     else return n * Factorial(n - 1);
// }
// // Но есть проблема: когда мы будем вычислять большие числа (допустим,
// //40!), в какой-то момент начнём получать отрицательные числа, чего быть не должно. 
// for (int i = 1; i < 40; i++)
// {
//     Console.WriteLine(Factorial(i));
// }
// // Это связано с переполнением типа. Давайте проверим, 
// // до какого значения можем посчитать факториал.
// int Factorial(int n)
// {
//  // 1! = 1
//  // 0! = 1
//  if(n == 1) return 1;
//  else return n * Factorial(n-1);
// }
// for (int i = 1; i < 40; i++)
// {
//  Console.WriteLine($"{i}! = {Factorial(i)}");
// }
// То есть число 17! попросту не вмещается в тип данных integer, поэтому появляется первая ваша задача,
// связанная с переполнением. Как её решать? Разными способами. Есть тип данных, который такие числа
// ещё способен переваривать, — double. Давайте integer заменим на double для возвращаемого
// результата. Потому что аргументом мы здесь передаём только число до 40.
double Factorial(int n)
{
 // 1! = 1
 // 0! = 1
 if(n == 1) return 1;
 else return n * Factorial(n-1);
}
for (int i = 1; i < 40; i++)
{
 Console.WriteLine($"{i}! = {Factorial(i)}");
}
// Видим нормальные значения. E + 29 означает, что получившееся число нужно 
// умножить на 10в29степ. Это достаточно большие числа. Но тип double позволяет их хранить. 
Console.WriteLine(Factorial(3)); // 1 * 2 * 3 = 6

